---
title: "Chapter Two -- Introduction to R"
author: "Ryan Elmore"
date: "`r Sys.Date()`"
output:
  word_document: default
  pdf_document: default
---

```{r knitr-options, include = FALSE}
knitr::opts_chunk$set(fig.align="center",
                      warning = FALSE,
                      message = FALSE,
                      comment = NA)
```

```{r, include = F}
library(Lahman)
library(dplyr)
library(ggplot2)
```

```{r, include = F}
set.seed(1928)
```

# Background

Take a look at the .R file that we used in the first (or second) class. Notice
that it was just a mash-up of R code and comments, and that's it. And that was 
intentional. That's what `.R` files are all about: R code and comments. We tried
using the comments to provide a narrative as to what we were doing in the code. 
That's sub-optimal at best when it comes to delivering a report along with code.
Fortunately, there are better ways of weaving a story into a code-based file and
that's usually through the use of ["literate programming"](https://en.wikipedia.org/wiki/Literate_programming) principles.
That is, we can write a document (or slideshow, dashboard, etc.) while we 
program...and, really, does it get any better than that, folks? 

One of the ways to implement literate programming in R is to use a variant of 
markdown called [R Markdown](https://rmarkdown.rstudio.com). Note that the file
extension for an R Markdown document is `.Rmd` as opposed to `.R` for a straight 
R file. One of the primary benefits (among many) to this style of programming is
that your work should be fully reproducible at the completion of your project, 
i.e. a colleague should be able to reproduce your analysis, write-up, etc. if 
you share the `.Rmd` file (and data) with them.

This document is an attempt to clarify a few points related to the basics of R,
RMarkdown, and RStudio. R is not RStudio. R is not R Markdown. R Markdown is not 
RStudio. Now that this is out of the way, let's get started. We start with a few 
definitions.

1. [R](http://www.r-project.org): From the R Project's website, "R is a free
software environment for statistical computing and graphics. It compiles and 
runs on a wide variety of UNIX platforms, Windows and MacOS."
2. [RStudio](http://www.rstudio.com): From the RStudio website, "RStudio is an
integrated development environment (IDE) for R. It includes a console,
syntax-highlighting editor that supports direct code execution, as well as tools
for plotting, history, debugging and workspace management." RStudio works on 
Mac, Windows, and linux. 
3. [R Markdown](https://rmarkdown.rstudio.com): RStudio's flavor of the markdown
language.

# R

R is the statistical programming language that we will use in this class. It's 
great for statistical programming because it was developed by statisticians! On
the other hand, it's not great for general purpose programming because it was 
developed by statisticians.

# Why R Markdown?

At its core, R Markdown is just another variant of
[Markdown](https://www.markdownguide.org), developed by RStudio. As such, it 
helps to understand a little bit about Markdown, and we will get to that. 
First, we just point out that R Markdown allows the user to keep *all* of your
analysis code, output, and thoughts/comments/conclusions in a single 
document. In addition, R Markdown can be used to produce reports (Word, pdf,
HTML, github docs), dashboards, slides, among other types of output, *i.e.* R
Markdown is extremely flexible as a tool. 

# From R to R Markdown

I, though this is not gospel, tend to do preliminary work in a `.R` file, and 
then transfer that work to a `.Rmd` file once I'm happy with the work. Lately, 
however, I just start with `.Rmd` and do everything there. Whatever makes you
happy, do that.

# RStudio

We will use the RStudio IDE in this class to write code, manage our software
projects, etc. Seriously, if you are going to write code in R, use this IDE. 
Ordinarily (in non-COVID-19 years), I would demonstrate everything using a 
DU-hosted RStudio server in class. I may still do this, but I would imagine that
a fair amount of my work this quarter will be on my laptop (Mac) using RStudio
locally.

# R Basics

We are going to focus on using R for statistical analysis and, as a result,
we will rely heavily upon the [tidyverse](https://www.tidyverse.org). There
is merit in using and learning "base" R, but I believe that the unified 
syntax presented in the tidyverse (and its many add-ons) allows us to focus on
the data wrangling, analysis, and output, rather than peculiar programming
requirements in base R. If you are already familiar with base R, here is a 
[handy guide](http://www.significantdigits.org/2017/10/switching-from-base-r-to-tidyverse/)
for transitioning from base R into the tidyverse style. 

## Data Manipulation

Quite a bit of the R code that I am using in this report is taken directly from
the `tues-r-basics-lahman.R` file that we discussed in a previous class. Please
read that file, understand what is going on there, and then come back to this 
file. 

```{r batting}
df <- tibble(Batting)
```

```{r}
str(df)
```

Note that this `df` object is a "tibble", a more flexible data.frame in R. 

## Traditional indexing vs dplyr verbs

### Traditional 

Suppose we want to select the AB (at bats) column of `df`. There are a host of 
ways that you can do this in base R, e.g. `df$AB` or `df[, "AB"]`, or `df[, 7]`,
if you know that AB is located in the seventh column. The numeric indexing applies 
to both rows and columns. For example, suppose we want the first 5 observations
from the $2^{nd}$ and $4^{th}$ columns of `df`. We can access this information by
issuing `df[1:5, c(2, 4)]`. Recall from the `.R` file that `1:5` and `c(2, 4)`
are just vectors. Note that for two generic vectors `v1` and `v2`, we can  get 
the `v1` rows and `v2` columns from `df` by `df[v1, v2]`. So you can define 
indexing vectors in a lot of different ways to extract data from a data object.

### dplyr

The [dplyr](http://dplyr.tidyverse.org) package (part of the tidyverse) provides 
a "grammar of data manipulation, providing a consistent set of verbs that help 
you solve the most common data manipulation challenges:" `mutate()`, `select()`, 
`filter()`, `summarize()`, and `arrange`. I tend to think of dplyr as a SQL-like
syntax for R. For reasons that will hopefully become obvious as the quarter 
progresses, dplyr (and other packages) rely heavily on the "pipe" operator that 
was introduced in the [magrittr](http://magrittr.tidyverse.org) package and, in
fact, dplyr "imports" the magrittr package upon loading dyply. The best way to
learn dplyr is to do dplyr. Here's an example.

```{r bat-hr}
df <- tibble(Batting) %>%
  filter(., teamID %in% c("COL", "MIA", "FLO")) %>%
  mutate(., 
         teamID = as.character(teamID),
         teamID = if_else(teamID == "FLO", "MIA", teamID)) %>%
  group_by(., teamID, yearID) %>%
  summarize(., team_hr = sum(HR))
```

# New R Markdown File

In order to create a new R Markdown document (`.Rmd` file), 
`File -> New File -> R Markdown` within RStudio. A default template will show up
in your text editing window within RStudio. The template is customizable for 
your own needs, but it requires a little hacking around to do this. 

## R Markdown Document Structure

R Markdown documents (in the most basic form) will have three parts. 

1. YAML - Header information that includes title, author, date, and output type
(*e.g.*, pdf or HTML) at a minimum. An example YAML section might look like the
following text. 

```
---
title: "R Markdown, RStudio, and R"
author: "Ryan Elmore"
date: "`r format(Sys.Date(), '%d %b %Y')`"
output: 
  pdf_document
toc: TRUE
---
```

2. Markdown Code - Your section headings, lists, comments, conclusions, etc. is
all written in markdown. There are a million references online for learning
about markdown. Or just read my `.Rmd` documents for just about everything that
you would need to know regarding markdown for the purposes of this class 
(outside of YAML and R code chunks). 

3. R Code - The actual R part of your `.Rmd` document is embedded within what we
refer to as "code chunks". R can be placed inline, e.g. `` `mean(rnorm(50))` ``
would evalue the mean of 50 random normal variates within the document *e.g.*
`r mean(rnorm(50))`. The other way to insert R into a document is to include a
stand-alone chunk by using the three back ticks method, e.g. 

````
```{r, eval = FALSE}`r ''`
p <- ggplot(df,
            aes(x = yearID, y = team_hr, col = teamID))

p + geom_point() +
  geom_line() +
  facet_grid(~ teamID) +
  scale_color_brewer(palette = "Set1") +
  labs(
    x = "year",
    y = "home runs",
    title = "Home Runs by Year",
    subtitle = "something"
  ) +
  guides(col = FALSE) +
  theme_bw()
```
````

The only R code in that previous text chunk is the stuff contained on the lines 
between the `` ``` ``, or the following text.

```{r, eval = FALSE}
p <- ggplot(df,
            aes(x = yearID, y = team_hr, col = teamID))

p + geom_point() +
  geom_line() +
  facet_grid(~ teamID) +
  scale_color_brewer(palette = "Set1") +
  labs(
    x = "year",
    y = "home runs",
    title = "Home Runs by Year",
    subtitle = "COL vs MIA"
  ) +
  guides(col = FALSE) +
  theme_bw()
```

I usually organize my `.Rmd` documents in the following way:

1. YAML heading
2. I will put an R code chunk at the top of the document with the packages that 
I refer to as the `lib` for library. 
3. After 2., I import any necessary data and call that code chunk `data`. 
4. I then weave text and R code chunks throughout the rest of the document.

## Lahman Data

Assuming the `YAML` has been entered, I'll define the packages that are used.
Note that I am using first the `knitr` option `eval = FALSE` in order to 
illustrate how you can include code but not evaluate it and next I use 
`include = FALSE` so that this chunk isn't included in the final document.

```{r lib, eval = FALSE} 
## This code chunk is not being evaluated but it's included in the doc.
library(Lahman)
library(dplyr)
library(ggplot2)
```

```{r libs, include = FALSE}
## This code chunk is being evaluated but it's not included in the doc.
library(Lahman)
library(dplyr)
library(ggplot2)
```

Next, I usually import and/or manipulate data and, again, I won't include 
this chunk in the document. See the `.Rmd` file for the data manipulation code.
Finally, I will write the document by weaving text with code. For example, 
Figure \ref{fig:fig-team-hrs} shows the home runs per year for each of the 
Colorado Rockies and the Florida/Miami Marlins. 

```{r data, include = F}
df <- tibble(Batting) %>%
  filter(., teamID %in% c("COL", "MIA", "FLO")) %>%
  mutate(., 
         teamID = as.character(teamID),
         teamID = if_else(teamID == "FLO", "MIA", teamID)) %>%
  group_by(., teamID, yearID) %>%
  summarize(., team_hr = sum(HR))
```


## A Figure

Note that in this figure, I first define a plot object that I name `p`. In order
to view the figure, you __must__ add layers to the plot. The first layer that I 
add is the `geom_point()` layer, next is `geom_line()`, and so on. 

```{r fig, echo = FALSE, fig.width = 6.5, fig.cap='\\label{fig:fig-team-hrs} Home runs for each team over the years.'}
p <- ggplot(df,
            aes(x = yearID, y = team_hr, col = teamID))

p + geom_point() +
  geom_line() +
  facet_grid(~ teamID) +
  scale_color_brewer(palette = "Set1") +
  labs(
    x = "year",
    y = "home runs",
    title = "Home Runs by Year",
    subtitle = "COL & MIA"
  ) +
  guides(col = FALSE) +
  theme_bw()
```

### A small heading

#### even smaller heading

# Extracting R Code

Finally, it's worth mentioning that you can extract all of the R code from a
`.Rmd` file and put it into an `.R` file using the `purl()` function from the
`knitr` package. The only way I know how to do this is within the R Console 
window. As an example, suppose you have an R Markdown file named 
`thur-rmarkdown-lahman.Rmd` and you want to extract all R commands to 
`thur-rmarkdown-lahman.R`. In order to do this, you issue the following command
from the Console prompt.

```{r, eval = F}
knitr::purl(input = "thur-rmarkdown-lahman.Rmd",
            output = "thur-rmarkdown-lahman.R")
```
I don't necessarily advocate for using `knitr::purl()` too often given that I 
am picky about R code. However, it does the job. 

Note that you could create a new `.R` file by simply `File -> New File ->
R Script`. This is simply a text file and the commands are entered into the R 
Console window. 

## Resources
1. [RMarkdown on RStudio](https://rmarkdown.rstudio.com)
2. [RMarkdown Cheatsheet](https://rmarkdown.rstudio.com/lesson-15.html)


Let's look at the Pitching data from the Lahman database. Recall, here is the 
information related to the
[Lahman Database](http://seanlahman.com/baseball-archive/statistics)
for baseball statistics. I will create a tibble from the `Pitching` object 
from the `Lahman` package that we will use in this lab. 

```{r}
pitch_df <- tibble(Pitching)
```

### Question 1

Choose two teams from the database. Define a new data frame by filtering the
original data frame to include only those two teams. How many rows are in the
new data frame?

### Answer 1

```{r}
new_df <- pitch_df %>%
  filter(., teamID %in% c("CIN", "PHI"))
nrow(new_df)
```

### Question 2

Using the teams from 1, compute the total earned runs (ER) given
up for each team by year. Plot your results using points and lines for 1970
through 2018 colored by teamID.

### Answer 2

```{r}
p <- new_df %>%
  filter(teamID %in% c("CIN", "PHI")) %>%
  group_by(yearID, teamID) %>%
  summarize(total_er = sum(ER)) %>%
  filter(yearID >= 1970) %>%
  ggplot(., aes(yearID, total_er, col = teamID))
p + geom_point() +
  geom_line() +
  scale_color_brewer(palette = "Set1") +
  labs(
    x = "year",
    y = "total ER"
  )
```

### Question 3

Create a new data frame using the Batting data from Lahman and filter based on
the Colorado Rockies. Call this new data frame `col_df`.

### Answer 3

```{r}
col_df <- tbl_df(Batting) %>%
  filter(teamID == "COL")
```

### Question 4

Slugging Percentage (SLG) is a baseball metric that computes a player's 
total bases per at bat. Total bases is defined as 

$$
TB = singles + 2*doubles + 3*triples + 4*(home\ runs).
$$

Add two columns to `col_df` defined as total bases and SLG Note that some
players with have `NaN` due to zero ABs. Pipe your result into the `na.omit()`
function at the end of your definition.

### Answer 4

```{r}
col_df <- col_df %>%
  filter(teamID == "COL") %>%
  mutate(X1B = H - X2B - X3B - HR, #singles
         TB = X1B + 2*X2B + 3*X3B + 4*HR,
         SLG = TB/AB) %>%
  na.omit()
```

### Question 5

Plot the average SLG per year for the Rockies from 1993 - 2018.

### Answer 5

```{r}
col_df_2 <- col_df %>%
  group_by(yearID, teamID) %>%
  summarize(avg_slg = mean(SLG)) %>%
  filter(yearID >= 1993) 

p <- ggplot(data = col_df_2,
            aes(yearID, avg_slg))
p + geom_point() +
  geom_line() +
  scale_x_continuous(breaks = seq(1990, 2020, by = 5)) +
  labs(
    x = "year",
    y = "average SLG"
  )
```

Alternatively, someone wrote in saying that this solution looks a bit wacky in
comparison to what is given on MLB's website or baseball-reference.com. This is 
because I asked for the average SLG and not the team SLG. Remember, there are a 
lot of pitchers included in this average and they generally aren't great 
hitters [^1]. If you want to see the team SLG for the Rockies, you could do the
following. 

```{r}
col_df_3 <- col_df %>%
  group_by(yearID, teamID) %>%
  summarize(team_slg = sum(TB)/sum(AB)) %>%
  filter(yearID >= 1993) 

p <- ggplot(data = col_df_3,
            aes(yearID, team_slg))
p + geom_point() +
  geom_line() +
  scale_x_continuous(breaks = seq(1990, 2020, by = 5)) +
  labs(
    x = "year",
    y = "team SLG"
  )
```


[^1:] I did see Jon Gray (Rockies' pitcher) hit a home run to dead center once 
against the Cincinnati Reds at Coors Field. I think it went 450 feet or so. He
absolutely crushed it. Here's [a video](https://www.youtube.com/watch?v=XtWIFTIaC6E). 
